<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #121212;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #1a1a1a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pdf-container {
            position: absolute;
            transform-origin: center center;
            will-change: transform;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #pdf-canvas {
            display: block;
            background: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            cursor: grab;
            max-width: 100%;
            max-height: 100%;
        }

        #pdf-canvas:active {
            cursor: grabbing;
        }

        .annotation-mode {
            cursor: crosshair !important;
        }

        .page-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            z-index: 100;
            pointer-events: none;
        }

        .mode-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            z-index: 100;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
            display: none;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .annotation {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            z-index: 10;
        }

        .highlight {
            border-radius: 2px;
            background: rgba(255, 235, 59, 0.4);
        }

        .rectangle {
            border: 2px solid;
            background: transparent;
        }

        .line {
            background: transparent;
            transform-origin: 0 0;
        }

        .line-inner {
            position: absolute;
            top: -1px;
            left: 0;
            width: 100%;
            height: 2px;
            background: currentColor;
        }

        .note-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2d2d2d;
            border-radius: 24px 24px 0 0;
            padding: 24px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }

        .note-sheet.active {
            transform: translateY(0);
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .note-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
        }

        .close-btn {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            background: #3b3b3b;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .note-textarea {
            width: 100%;
            height: 150px;
            background: #3b3b3b;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
            color: white;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            margin-bottom: 20px;
        }

        .note-textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .save-btn {
            width: 100%;
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .save-btn:hover {
            background: #2563eb;
        }

        .delete-btn {
            width: 100%;
            padding: 16px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 12px;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }

        .zoom-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .annotation-toolbar {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 12px;
            display: flex;
            gap: 8px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .annotation-toolbar.active {
            display: flex;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            border: none;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tool-btn.active {
            background: #3b82f6;
            transform: scale(1.1);
        }

        .tool-btn:hover {
            background: #444;
        }

        .color-picker {
            display: flex;
            gap: 6px;
            margin-left: 8px;
            align-items: center;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-option.active {
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .swipe-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 12px;
            color: #aaa;
            backdrop-filter: blur(10px);
            pointer-events: none;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        .shape-indicator {
            position: fixed;
            top: 60px;
            left: 20px;
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            padding: 4px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            display: none;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div class="container" id="main-container">
        <div class="pdf-container" id="pdf-container">
            <canvas id="pdf-canvas"></canvas>
        </div>
        
        <div class="page-info">Page: <span id="page-num">1</span> / <span id="page-count">1</span></div>
        <div class="mode-indicator" id="mode-indicator">Annotation Mode</div>
        <div class="shape-indicator" id="shape-indicator">Highlight</div>
        <div class="zoom-indicator" id="zoom-indicator">100%</div>
        
        <div class="annotation-toolbar" id="annotation-toolbar">
            <button class="tool-btn active" id="tool-highlight" title="Highlight">H</button>
            <button class="tool-btn" id="tool-rectangle" title="Rectangle">□</button>
            <button class="tool-btn" id="tool-line" title="Line">─</button>
            <div class="color-picker">
                <div class="color-option active" style="background: rgba(255, 235, 59, 0.8);" data-color="rgba(255, 235, 59, 0.4)" data-border="#ffeb3b"></div>
                <div class="color-option" style="background: rgba(33, 150, 243, 0.8);" data-color="rgba(33, 150, 243, 0.4)" data-border="#2196f3"></div>
                <div class="color-option" style="background: rgba(76, 175, 80, 0.8);" data-color="rgba(76, 175, 80, 0.4)" data-border="#4caf50"></div>
                <div class="color-option" style="background: rgba(244, 67, 54, 0.8);" data-color="rgba(244, 67, 54, 0.4)" data-border="#f44336"></div>
                <div class="color-option" style="background: rgba(156, 39, 176, 0.8);" data-color="rgba(156, 39, 176, 0.4)" data-border="#9c27b0"></div>
            </div>
        </div>
        
        <div class="loading" id="loading">Loading PDF...</div>
        <div class="swipe-hint">Long press to annotate • Pinch to zoom • Pan after zoom • Double tap to reset</div>
    </div>

    <div class="overlay" id="overlay"></div>
    
    <div class="note-sheet" id="note-sheet">
        <div class="note-header">
            <div class="note-title">Note</div>
            <button class="close-btn" id="close-note">×</button>
        </div>
        <textarea class="note-textarea" id="note-text" placeholder="Type your note here..."></textarea>
        <button class="save-btn" id="save-note">Save Note</button>
        <button class="delete-btn" id="delete-highlight">Delete Annotation</button>
    </div>

    <script>
        class GesturePDFViewer {
            constructor() {
                this.pdfDoc = null;
                this.currentPage = 1;
                this.baseScale = 1.0;
                this.currentScale = 1.0;
                this.minScale = 0.5;
                this.maxScale = 3.0;
                
                // Canvas and rendering
                this.canvas = document.getElementById('pdf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.pdfContainer = document.getElementById('pdf-container');
                this.mainContainer = document.getElementById('main-container');
                
                // PDF rendering context
                this.renderContext = {
                    canvasContext: this.ctx,
                    viewport: null
                };
                
                // Transform state
                this.transform = {
                    x: 0,
                    y: 0,
                    scale: 1
                };
                
                // Animation
                this.animationId = null;
                
                // Gesture state
                this.isAnnotationMode = false;
                this.isPinching = false;
                this.isPanning = false;
                this.isEdgeSwiping = false;
                
                // Touch state
                this.touchStart = null;
                this.lastTap = 0;
                this.longPressTimer = null;
                
                // Pinch state
                this.pinchStartDistance = 0;
                this.pinchStartScale = 1;
                this.pinchCenter = { x: 0, y: 0 };
                this.lastPinchCenter = { x: 0, y: 0 };
                
                // Pan state
                this.velocity = { x: 0, y: 0 };
                
                // Annotation state
                this.annotations = new Map();
                this.currentAnnotation = null;
                this.activeAnnotation = null;
                this.annotationStart = null;
                this.annotationType = 'highlight';
                this.annotationColor = 'rgba(255, 235, 59, 0.4)';
                this.borderColor = '#ffeb3b';
                
                this.init();
            }

            async init() {
                const pdfUrl = 'https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf';
                
                try {
                    document.getElementById('loading').style.display = 'block';
                    
                    // Load PDF
                    const loadingTask = pdfjsLib.getDocument(pdfUrl);
                    this.pdfDoc = await loadingTask.promise;
                    
                    document.getElementById('page-count').textContent = this.pdfDoc.numPages;
                    
                    // Load annotations
                    this.loadAnnotations();
                    
                    // Render first page
                    await this.renderPage(this.currentPage);
                    
                    document.getElementById('loading').style.display = 'none';
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    // Start animation loop
                    this.animate();
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    document.getElementById('loading').textContent = 'Error loading PDF';
                }
            }

            setupEventListeners() {
                // Touch events
                this.mainContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.mainContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.mainContainer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Mouse events (for desktop testing)
                this.mainContainer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.mainContainer.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.mainContainer.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.mainContainer.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
                
                // Double tap detection
                this.mainContainer.addEventListener('touchend', this.handleTap.bind(this));
                this.mainContainer.addEventListener('click', this.handleClick.bind(this));
                
                // Note sheet controls
                document.getElementById('close-note').addEventListener('click', () => this.hideNoteSheet());
                document.getElementById('save-note').addEventListener('click', () => this.saveNote());
                document.getElementById('delete-highlight').addEventListener('click', () => this.deleteAnnotation());
                document.getElementById('overlay').addEventListener('click', () => this.hideNoteSheet());
                
                // Annotation toolbar
                document.getElementById('tool-highlight').addEventListener('click', () => this.setAnnotationType('highlight'));
                document.getElementById('tool-rectangle').addEventListener('click', () => this.setAnnotationType('rectangle'));
                document.getElementById('tool-line').addEventListener('click', () => this.setAnnotationType('line'));
                
                // Color picker
                document.querySelectorAll('.color-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('active'));
                        e.target.classList.add('active');
                        this.annotationColor = e.target.dataset.color;
                        this.borderColor = e.target.dataset.border;
                        this.updateShapeIndicator();
                    });
                });
                
                // Handle viewport resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            handleTouchStart(e) {
                e.preventDefault();
                
                if (e.touches.length === 2) {
                    this.isPinching = true;
                    this.isAnnotationMode = false;
                    this.hideAnnotationToolbar();
                    document.getElementById('mode-indicator').style.display = 'none';
                    
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    this.pinchCenter = this.getTouchCenter(touch1, touch2);
                    this.lastPinchCenter = { ...this.pinchCenter };
                    this.pinchStartDistance = this.getTouchDistance(touch1, touch2);
                    this.pinchStartScale = this.transform.scale;
                    
                    this.touchStart = {
                        x: this.pinchCenter.x,
                        y: this.pinchCenter.y,
                        time: Date.now()
                    };
                    
                    return;
                }

                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    this.touchStart = {
                        x: touch.clientX,
                        y: touch.clientY,
                        time: Date.now()
                    };
                    
                    // Check if touch started in edge zone
                    const screenWidth = window.innerWidth;
                    const isLeftEdge = touch.clientX < 50;
                    const isRightEdge = touch.clientX > screenWidth - 50;
                    
                    if (isLeftEdge || isRightEdge) {
                        this.isEdgeSwiping = true;
                    }

                    if (!this.isPinching && !this.isEdgeSwiping) {
                        this.longPressTimer = setTimeout(() => {
                            if (!this.isPinching && !this.isEdgeSwiping) {
                                this.enterAnnotationMode();
                            }
                        }, 650);
                    }
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                
                if (e.touches.length === 2 && this.isPinching) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = this.getTouchDistance(touch1, touch2);
                    
                    if (this.pinchStartDistance > 0) {
                        const scaleChange = currentDistance / this.pinchStartDistance;
                        const newScale = this.pinchStartScale * scaleChange;
                        
                        this.transform.scale = Math.max(this.minScale, Math.min(newScale, this.maxScale));
                        
                        const currentCenter = this.getTouchCenter(touch1, touch2);
                        const centerDeltaX = currentCenter.x - this.lastPinchCenter.x;
                        const centerDeltaY = currentCenter.y - this.lastPinchCenter.y;
                        
                        this.transform.x += centerDeltaX;
                        this.transform.y += centerDeltaY;
                        
                        this.lastPinchCenter = currentCenter;
                        this.updateZoomIndicator();
                        this.applyTransform();
                    }
                    return;
                }

                if (e.touches.length === 1 && this.touchStart && !this.isPinching) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touchStart.x;
                    const deltaY = touch.clientY - this.touchStart.y;
                    
                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                        
                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                this.previousPage();
                            } else {
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            return;
                        }
                        
                        if (this.transform.scale > this.baseScale && !this.isAnnotationMode) {
                            this.isPanning = true;
                            this.transform.x += deltaX;
                            this.transform.y += deltaY;
                            
                            this.constrainPan();
                            this.touchStart.x = touch.clientX;
                            this.touchStart.y = touch.clientY;
                            this.applyTransform();
                        }
                        
                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleAnnotation(touch.clientX, touch.clientY);
                        }
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isPinching) {
                    this.isPinching = false;
                    this.pinchStartDistance = 0;
                }
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isPanning) {
                    this.isPanning = false;
                    
                    if (this.touchStart) {
                        const now = Date.now();
                        const timeDiff = now - this.touchStart.time;
                        
                        if (timeDiff > 0) {
                            const touch = e.changedTouches[0] || this.touchStart;
                            const deltaX = touch.clientX - this.touchStart.x;
                            const deltaY = touch.clientY - this.touchStart.y;
                            
                            this.velocity.x = deltaX / timeDiff * 16;
                            this.velocity.y = deltaY / timeDiff * 16;
                        }
                    }
                }
                
                if (this.isAnnotationMode && this.currentAnnotation) {
                    this.finalizeAnnotation();
                }
                
                this.touchStart = null;
            }

            handleMouseDown(e) {
                this.touchStart = {
                    x: e.clientX,
                    y: e.clientY,
                    time: Date.now()
                };

                const isLeftEdge = e.clientX < 50;
                const isRightEdge = e.clientX > window.innerWidth - 50;

                if (isLeftEdge || isRightEdge) {
                    this.isEdgeSwiping = true;
                }

                if (!this.isEdgeSwiping) {
                    this.longPressTimer = setTimeout(() => {
                        if (!this.isEdgeSwiping) {
                            this.enterAnnotationMode();
                        }
                    }, 650);
                }
            }

            handleMouseMove(e) {
                if (this.touchStart) {
                    const deltaX = e.clientX - this.touchStart.x;
                    const deltaY = e.clientY - this.touchStart.y;

                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;

                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                this.previousPage();
                            } else {
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            return;
                        }

                        if ((e.ctrlKey || this.transform.scale > this.baseScale) && !this.isAnnotationMode) {
                            this.transform.x += deltaX;
                            this.transform.y += deltaY;
                            
                            this.constrainPan();
                            this.touchStart.x = e.clientX;
                            this.touchStart.y = e.clientY;
                            this.applyTransform();
                        }

                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleAnnotation(e.clientX, e.clientY);
                        }
                    }
                }
            }

            handleMouseUp() {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isAnnotationMode && this.currentAnnotation) {
                    this.finalizeAnnotation();
                }
                
                this.touchStart = null;
            }

            handleWheel(e) {
                if (e.ctrlKey) {
                    e.preventDefault();
                    
                    const rect = this.mainContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const oldScale = this.transform.scale;
                    const newScale = Math.max(this.minScale, Math.min(oldScale * zoomFactor, this.maxScale));
                    
                    if (newScale !== oldScale) {
                        const pdfX = (x - this.transform.x) / oldScale;
                        const pdfY = (y - this.transform.y) / oldScale;
                        
                        this.transform.scale = newScale;
                        this.transform.x = x - pdfX * newScale;
                        this.transform.y = y - pdfY * newScale;
                        
                        this.constrainPan();
                        this.applyTransform();
                        this.updateZoomIndicator();
                    }
                }
            }

            handleTap(e) {
                const now = Date.now();
                const timeSinceLastTap = now - this.lastTap;
                
                if (timeSinceLastTap < 300) {
                    this.resetZoom();
                    e.preventDefault();
                }
                
                this.lastTap = now;
            }

            handleClick(e) {
                if (this.isAnnotationMode) {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (e.clientX - rect.left) / this.transform.scale;
                    const canvasY = (e.clientY - rect.top) / this.transform.scale;
                    
                    const annotation = this.findAnnotationAt(canvasX, canvasY);
                    if (annotation) {
                        this.showNoteSheet(annotation);
                    }
                }
            }

            getTouchCenter(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }

            getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            applyTransform() {
                this.pdfContainer.style.transform = `
                    translate(${this.transform.x}px, ${this.transform.y}px)
                    scale(${this.transform.scale})
                `;
            }

            constrainPan() {
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight;
                
                const scaledWidth = canvasWidth * this.transform.scale;
                const scaledHeight = canvasHeight * this.transform.scale;
                
                // Allow panning only within bounds
                const maxX = Math.max(0, (scaledWidth - containerWidth) / 2);
                const maxY = Math.max(0, (scaledHeight - containerHeight) / 2);
                
                this.transform.x = Math.max(-maxX, Math.min(maxX, this.transform.x));
                this.transform.y = Math.max(-maxY, Math.min(maxY, this.transform.y));
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                const now = Date.now();
                const deltaTime = Math.min(now - (this.lastFrameTime || now), 100) / 16;
                this.lastFrameTime = now;
                
                if (!this.isPanning && !this.isPinching && (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1)) {
                    this.transform.x += this.velocity.x * deltaTime;
                    this.transform.y += this.velocity.y * deltaTime;
                    
                    this.constrainPan();
                    this.velocity.x *= 0.9;
                    this.velocity.y *= 0.9;
                    this.applyTransform();
                    
                    if (Math.abs(this.velocity.x) < 0.1 && Math.abs(this.velocity.y) < 0.1) {
                        this.velocity.x = 0;
                        this.velocity.y = 0;
                    }
                }
            }

            async renderPage(pageNum) {
                if (!this.pdfDoc || pageNum < 1 || pageNum > this.pdfDoc.numPages) return;
                
                this.currentPage = pageNum;
                document.getElementById('page-num').textContent = pageNum;
                
                // Clear existing annotations
                document.querySelectorAll('.annotation').forEach(el => el.remove());
                
                const page = await this.pdfDoc.getPage(pageNum);
                
                // Calculate optimal scale to fill screen
                const viewport = page.getViewport({ scale: 1 });
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight;
                
                // Calculate scale to fit width and height with 5% padding
                const scaleX = (containerWidth * 0.95) / viewport.width;
                const scaleY = (containerHeight * 0.95) / viewport.height;
                const fitScale = Math.min(scaleX, scaleY);
                
                // Set scales
                this.baseScale = fitScale;
                this.currentScale = fitScale;
                this.transform.scale = fitScale;
                this.minScale = fitScale * 0.5;
                this.maxScale = fitScale * 3.0;
                
                // Reset position to center
                this.transform.x = 0;
                this.transform.y = 0;
                this.velocity = { x: 0, y: 0 };
                
                // Create viewport with calculated scale
                const actualViewport = page.getViewport({ scale: fitScale });
                
                // Set canvas dimensions with device pixel ratio
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = Math.floor(actualViewport.width * dpr);
                this.canvas.height = Math.floor(actualViewport.height * dpr);
                
                // Set CSS dimensions (scaled down by dpr for display)
                this.canvas.style.width = `${actualViewport.width}px`;
                this.canvas.style.height = `${actualViewport.height}px`;
                
                // Update render context
                this.renderContext.viewport = actualViewport;
                
                // Clear and render PDF
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                await page.render(this.renderContext).promise;
                
                // Apply initial transform
                this.applyTransform();
                this.updateZoomIndicator();
                
                // Restore annotations
                this.restoreAnnotations();
                
                // Exit annotation mode
                this.exitAnnotationMode();
            }

            enterAnnotationMode() {
                this.isAnnotationMode = true;
                this.canvas.style.cursor = 'crosshair';
                document.getElementById('mode-indicator').style.display = 'block';
                document.getElementById('annotation-toolbar').classList.add('active');
                document.getElementById('shape-indicator').style.display = 'block';
                this.updateShapeIndicator();
            }

            exitAnnotationMode() {
                this.isAnnotationMode = false;
                this.canvas.style.cursor = 'grab';
                document.getElementById('mode-indicator').style.display = 'none';
                document.getElementById('annotation-toolbar').classList.remove('active');
                document.getElementById('shape-indicator').style.display = 'none';
                this.currentAnnotation = null;
                this.annotationStart = null;
            }

            setAnnotationType(type) {
                this.annotationType = type;
                
                // Update toolbar buttons
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`tool-${type}`).classList.add('active');
                
                this.updateShapeIndicator();
            }

            updateShapeIndicator() {
                const indicator = document.getElementById('shape-indicator');
                const typeNames = {
                    'highlight': 'Highlight',
                    'rectangle': 'Rectangle',
                    'line': 'Line'
                };
                indicator.textContent = typeNames[this.annotationType];
                
                // Update color based on selected color
                const colorOption = document.querySelector('.color-option.active');
                if (colorOption) {
                    indicator.style.color = colorOption.dataset.border;
                    indicator.style.background = colorOption.dataset.color.replace('0.4', '0.2');
                }
            }

            hideAnnotationToolbar() {
                document.getElementById('annotation-toolbar').classList.remove('active');
                document.getElementById('shape-indicator').style.display = 'none';
            }

            handleAnnotation(screenX, screenY) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = (screenX - rect.left) / this.transform.scale;
                const canvasY = (screenY - rect.top) / this.transform.scale;
                
                if (!this.annotationStart) {
                    this.annotationStart = { x: canvasX, y: canvasY };
                    this.currentAnnotation = {
                        type: this.annotationType,
                        color: this.annotationColor,
                        borderColor: this.borderColor,
                        x: canvasX,
                        y: canvasY,
                        width: 0,
                        height: 0,
                        page: this.currentPage
                    };
                } else {
                    this.currentAnnotation.width = canvasX - this.annotationStart.x;
                    this.currentAnnotation.height = canvasY - this.annotationStart.y;
                    
                    // Draw temporary annotation
                    this.drawAnnotation(this.currentAnnotation);
                }
            }

            finalizeAnnotation() {
                if (this.currentAnnotation && 
                    (Math.abs(this.currentAnnotation.width) > 5 || Math.abs(this.currentAnnotation.height) > 5)) {
                    
                    // Normalize coordinates
                    if (this.currentAnnotation.width < 0) {
                        this.currentAnnotation.x += this.currentAnnotation.width;
                        this.currentAnnotation.width = Math.abs(this.currentAnnotation.width);
                    }
                    if (this.currentAnnotation.height < 0) {
                        this.currentAnnotation.y += this.currentAnnotation.height;
                        this.currentAnnotation.height = Math.abs(this.currentAnnotation.height);
                    }
                    
                    // Ensure minimum size
                    if (this.currentAnnotation.type === 'line') {
                        this.currentAnnotation.width = Math.max(this.currentAnnotation.width, 20);
                        this.currentAnnotation.height = Math.max(this.currentAnnotation.height, 2);
                    } else {
                        this.currentAnnotation.width = Math.max(this.currentAnnotation.width, 10);
                        this.currentAnnotation.height = Math.max(this.currentAnnotation.height, 10);
                    }
                    
                    this.currentAnnotation.id = Date.now().toString();
                    this.saveAnnotation(this.currentAnnotation);
                    this.drawAnnotation(this.currentAnnotation, true);
                }
                
                this.currentAnnotation = null;
                this.annotationStart = null;
            }

            drawAnnotation(annotation, permanent = false) {
                if (!permanent) {
                    document.querySelectorAll('.annotation:not([data-permanent])').forEach(el => el.remove());
                }
                
                const annotationEl = document.createElement('div');
                annotationEl.className = `annotation ${annotation.type}`;
                
                // Set position and size
                annotationEl.style.left = `${annotation.x * this.transform.scale}px`;
                annotationEl.style.top = `${annotation.y * this.transform.scale}px`;
                annotationEl.style.width = `${annotation.width * this.transform.scale}px`;
                annotationEl.style.height = `${annotation.height * this.transform.scale}px`;
                
                // Set styles based on type
                if (annotation.type === 'highlight') {
                    annotationEl.style.background = annotation.color;
                } else if (annotation.type === 'rectangle') {
                    annotationEl.style.border = `2px solid ${annotation.borderColor}`;
                } else if (annotation.type === 'line') {
                    // Calculate angle for line
                    const angle = Math.atan2(annotation.height, annotation.width) * (180 / Math.PI);
                    const length = Math.sqrt(annotation.width * annotation.width + annotation.height * annotation.height);
                    
                    annotationEl.style.width = `${length * this.transform.scale}px`;
                    annotationEl.style.height = '2px';
                    annotationEl.style.background = annotation.borderColor;
                    annotationEl.style.transform = `rotate(${angle}deg)`;
                    
                    // Add inner element for better rendering
                    const lineInner = document.createElement('div');
                    lineInner.className = 'line-inner';
                    annotationEl.appendChild(lineInner);
                }
                
                if (permanent) {
                    annotationEl.setAttribute('data-id', annotation.id);
                    annotationEl.setAttribute('data-permanent', 'true');
                    
                    annotationEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (this.isAnnotationMode) {
                            this.showNoteSheet(annotation);
                        }
                    });
                    
                    annotationEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (this.isAnnotationMode) {
                            this.deleteAnnotation(annotation.id);
                        }
                    });
                }
                
                this.pdfContainer.appendChild(annotationEl);
            }

            findAnnotationAt(x, y) {
                const annotations = this.annotations.get(this.currentPage) || [];
                return annotations.find(ann => {
                    // Simple bounding box check
                    return x >= ann.x && x <= ann.x + ann.width &&
                           y >= ann.y && y <= ann.y + ann.height;
                });
            }

            updateZoomIndicator() {
                const percentage = Math.round((this.transform.scale / this.baseScale) * 100);
                document.getElementById('zoom-indicator').textContent = `${percentage}%`;
            }

            handleResize() {
                this.renderPage(this.currentPage);
            }

            nextPage() {
                if (this.currentPage < this.pdfDoc.numPages && !this.isAnnotationMode) {
                    this.renderPage(this.currentPage + 1);
                }
            }

            previousPage() {
                if (this.currentPage > 1 && !this.isAnnotationMode) {
                    this.renderPage(this.currentPage - 1);
                }
            }

            resetZoom() {
                this.transform.scale = this.baseScale;
                this.transform.x = 0;
                this.transform.y = 0;
                this.velocity = { x: 0, y: 0 };
                
                this.applyTransform();
                this.updateZoomIndicator();
            }

            saveAnnotation(annotation) {
                const pageAnnotations = this.annotations.get(annotation.page) || [];
                pageAnnotations.push(annotation);
                this.annotations.set(annotation.page, pageAnnotations);
                
                this.saveToStorage();
            }

            restoreAnnotations() {
                const pageAnnotations = this.annotations.get(this.currentPage) || [];
                pageAnnotations.forEach(annotation => {
                    this.drawAnnotation(annotation, true);
                });
            }

            showNoteSheet(annotation) {
                this.activeAnnotation = annotation;
                
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                const noteText = document.getElementById('note-text');
                
                noteText.value = annotation.note || '';
                noteSheet.classList.add('active');
                overlay.classList.add('active');
            }

            hideNoteSheet() {
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                
                noteSheet.classList.remove('active');
                overlay.classList.remove('active');
                
                this.activeAnnotation = null;
            }

            saveNote() {
                if (!this.activeAnnotation) return;
                
                const noteText = document.getElementById('note-text').value;
                this.activeAnnotation.note = noteText;
                
                const pageAnnotations = this.annotations.get(this.activeAnnotation.page) || [];
                const index = pageAnnotations.findIndex(a => a.id === this.activeAnnotation.id);
                if (index !== -1) {
                    pageAnnotations[index].note = noteText;
                    this.saveToStorage();
                }
                
                this.hideNoteSheet();
            }

            deleteAnnotation(annotationId = null) {
                const id = annotationId || (this.activeAnnotation && this.activeAnnotation.id);
                if (!id) return;
                
                const annotationEl = document.querySelector(`.annotation[data-id="${id}"]`);
                if (annotationEl) {
                    annotationEl.remove();
                }
                
                const pageAnnotations = this.annotations.get(this.currentPage) || [];
                const filtered = pageAnnotations.filter(a => a.id !== id);
                this.annotations.set(this.currentPage, filtered);
                
                this.saveToStorage();
                this.hideNoteSheet();
            }

            saveToStorage() {
                const data = Object.fromEntries(this.annotations);
                localStorage.setItem('pdfAnnotations', JSON.stringify(data));
            }

            loadAnnotations() {
                const saved = localStorage.getItem('pdfAnnotations');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.annotations = new Map(Object.entries(data));
                }
            }
        }

        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.viewer = new GesturePDFViewer();
        });
    </script>
</body>
</html>