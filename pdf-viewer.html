<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #121212;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
            touch-action: none; /* Disable all browser gestures */
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: #1a1a1a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pdf-container {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        #pdf-canvas {
            display: block;
            background: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            cursor: grab;
        }

        #pdf-canvas:active {
            cursor: grabbing;
        }

        .annotation-mode {
            cursor: crosshair !important;
        }

        .page-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            z-index: 100;
            pointer-events: none;
        }

        .mode-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            z-index: 100;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
            display: none;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .highlight {
            position: absolute;
            background: rgba(255, 235, 59, 0.4);
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
            z-index: 10;
            pointer-events: auto;
        }

        .highlight:hover {
            background: rgba(255, 235, 59, 0.6);
        }

        .note-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2d2d2d;
            border-radius: 24px 24px 0 0;
            padding: 24px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }

        .note-sheet.active {
            transform: translateY(0);
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .note-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
        }

        .close-btn {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            background: #3b3b3b;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .note-textarea {
            width: 100%;
            height: 150px;
            background: #3b3b3b;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
            color: white;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            margin-bottom: 20px;
        }

        .note-textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .save-btn {
            width: 100%;
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .save-btn:hover {
            background: #2563eb;
        }

        .delete-btn {
            width: 100%;
            padding: 16px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 12px;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }

        .zoom-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .swipe-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 12px;
            color: #aaa;
            backdrop-filter: blur(10px);
            pointer-events: none;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        .debug {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container" id="main-container">
        <div class="pdf-container" id="pdf-container">
            <canvas id="pdf-canvas"></canvas>
        </div>
        
        <div class="page-info">Page: <span id="page-num">1</span> / <span id="page-count">1</span></div>
        <div class="mode-indicator" id="mode-indicator">Annotation Mode</div>
        <div class="zoom-indicator" id="zoom-indicator">100%</div>
        
        <div class="loading" id="loading">Loading PDF...</div>
        <div class="swipe-hint">Swipe from edges to change pages • Pinch to zoom • Pan after zoom • Double tap to reset</div>
        <div class="debug" id="debug"></div>
    </div>

    <div class="overlay" id="overlay"></div>
    
    <div class="note-sheet" id="note-sheet">
        <div class="note-header">
            <div class="note-title">Note</div>
            <button class="close-btn" id="close-note">×</button>
        </div>
        <textarea class="note-textarea" id="note-text" placeholder="Type your note here..."></textarea>
        <button class="save-btn" id="save-note">Save Note</button>
        <button class="delete-btn" id="delete-highlight">Delete Highlight</button>
    </div>

    <script>
        class GesturePDFViewer {
            constructor() {
                this.pdfDoc = null;
                this.currentPage = 1;
                this.currentScale = 1.0;
                this.minScale = 0.5;
                this.maxScale = 3.0;
                this.baseScale = 1.0;
                
                this.renderContext = null;
                this.canvas = document.getElementById('pdf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.pdfContainer = document.getElementById('pdf-container');
                this.mainContainer = document.getElementById('main-container');
                
                // Transform state for zoom and pan
                this.transform = {
                    x: 0,
                    y: 0,
                    scale: 1
                };
                
                // Animation
                this.animationId = null;
                this.lastFrameTime = 0;
                
                // Gesture state
                this.isAnnotationMode = false;
                this.isPinching = false;
                this.isPanning = false;
                this.isEdgeSwiping = false;
                
                // Touch state
                this.touchStart = null;
                this.lastTap = 0;
                this.longPressTimer = null;
                
                // Pinch state
                this.pinchStartDistance = 0;
                this.pinchStartScale = 1;
                this.pinchCenter = { x: 0, y: 0 };
                this.lastPinchCenter = { x: 0, y: 0 };
                
                // Pan state
                this.panStart = { x: 0, y: 0 };
                this.velocity = { x: 0, y: 0 };
                this.lastTouchTime = 0;
                
                // Annotations
                this.annotations = new Map();
                this.currentHighlight = null;
                this.activeHighlight = null;
                this.highlightStart = null;
                
                this.init();
            }

            async init() {
                // For demo, using a sample PDF URL
                const pdfUrl = 'https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf';
                
                try {
                    document.getElementById('loading').style.display = 'block';
                    
                    // Load PDF
                    const loadingTask = pdfjsLib.getDocument(pdfUrl);
                    this.pdfDoc = await loadingTask.promise;
                    
                    document.getElementById('page-count').textContent = this.pdfDoc.numPages;
                    
                    // Setup canvas
                    this.setupCanvas();
                    
                    // Load annotations
                    this.loadAnnotations();
                    
                    // Render first page
                    await this.renderPage(this.currentPage);
                    
                    document.getElementById('loading').style.display = 'none';
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    // Start animation loop
                    this.animate();
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    document.getElementById('loading').textContent = 'Error loading PDF';
                }
            }

            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.renderContext = {
                    canvasContext: this.ctx,
                    viewport: null,
                    transform: [dpr, 0, 0, dpr, 0, 0]
                };
            }

            setupEventListeners() {
                // Touch events
                this.mainContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.mainContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.mainContainer.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Mouse events (for desktop testing)
                this.mainContainer.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.mainContainer.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.mainContainer.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.mainContainer.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
                
                // Double tap detection
                this.mainContainer.addEventListener('touchend', this.handleTap.bind(this));
                this.mainContainer.addEventListener('click', this.handleClick.bind(this));
                
                // Note sheet controls
                document.getElementById('close-note').addEventListener('click', () => this.hideNoteSheet());
                document.getElementById('save-note').addEventListener('click', () => this.saveNote());
                document.getElementById('delete-highlight').addEventListener('click', () => this.deleteHighlight());
                document.getElementById('overlay').addEventListener('click', () => this.hideNoteSheet());
                
                // Handle viewport resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            handleTouchStart(e) {
                e.preventDefault();
                
                if (e.touches.length === 2) {
                    // PINCH ZOOM START
                    this.isPinching = true;
                    this.isAnnotationMode = false;
                    document.getElementById('mode-indicator').style.display = 'none';
                    
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Calculate initial pinch center and distance
                    this.pinchCenter = this.getTouchCenter(touch1, touch2);
                    this.lastPinchCenter = { ...this.pinchCenter };
                    this.pinchStartDistance = this.getTouchDistance(touch1, touch2);
                    this.pinchStartScale = this.transform.scale;
                    
                    // Store touches for movement
                    this.touchStart = {
                        x: this.pinchCenter.x,
                        y: this.pinchCenter.y,
                        touches: [
                            { x: touch1.clientX, y: touch1.clientY },
                            { x: touch2.clientX, y: touch2.clientY }
                        ]
                    };
                    
                    return;
                }

                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    this.touchStart = {
                        x: touch.clientX,
                        y: touch.clientY,
                        time: Date.now(),
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    
                    // Check if touch started in edge zone (50px from edges)
                    const screenWidth = window.innerWidth;
                    const isLeftEdge = touch.clientX < 50;
                    const isRightEdge = touch.clientX > screenWidth - 50;
                    
                    if (isLeftEdge || isRightEdge) {
                        this.isEdgeSwiping = true;
                    }

                    // Start long press timer for annotation mode
                    if (!this.isPinching && !this.isEdgeSwiping) {
                        this.longPressTimer = setTimeout(() => {
                            if (!this.isPinching && !this.isEdgeSwiping) {
                                this.enterAnnotationMode();
                            }
                        }, 650);
                    }
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                
                if (e.touches.length === 2 && this.isPinching) {
                    // HANDLE PINCH ZOOM
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = this.getTouchDistance(touch1, touch2);
                    
                    if (this.pinchStartDistance > 0) {
                        // Calculate scale change
                        const scaleChange = currentDistance / this.pinchStartDistance;
                        const newScale = this.pinchStartScale * scaleChange;
                        
                        // Apply scale limits
                        this.transform.scale = Math.max(this.minScale, Math.min(newScale, this.maxScale));
                        
                        // Calculate current pinch center
                        const currentCenter = this.getTouchCenter(touch1, touch2);
                        
                        // Calculate how much the center moved since last frame
                        const centerDeltaX = currentCenter.x - this.lastPinchCenter.x;
                        const centerDeltaY = currentCenter.y - this.lastPinchCenter.y;
                        
                        // Update pan position based on center movement
                        this.transform.x += centerDeltaX;
                        this.transform.y += centerDeltaY;
                        
                        // Update last pinch center
                        this.lastPinchCenter = currentCenter;
                        
                        // Update zoom indicator
                        this.updateZoomIndicator();
                        
                        // Apply transform immediately
                        this.applyTransform();
                    }
                    return;
                }

                if (e.touches.length === 1 && this.touchStart && !this.isPinching) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touchStart.x;
                    const deltaY = touch.clientY - this.touchStart.y;
                    
                    // Clear long press timer if movement detected
                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                        
                        // Handle edge swipe for page change
                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                // Swipe right from left edge - previous page
                                this.previousPage();
                            } else {
                                // Swipe left from right edge - next page
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            return;
                        }
                        
                        // Handle panning (only if zoomed in)
                        if (this.transform.scale > this.baseScale && !this.isAnnotationMode) {
                            this.isPanning = true;
                            this.transform.x += deltaX;
                            this.transform.y += deltaY;
                            
                            // Apply constraints to prevent panning beyond edges
                            this.constrainPan();
                            
                            // Update touch start for next movement
                            this.touchStart.x = touch.clientX;
                            this.touchStart.y = touch.clientY;
                            
                            // Apply transform
                            this.applyTransform();
                        }
                        
                        // Handle highlighting in annotation mode
                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleHighlight(touch.clientX, touch.clientY);
                        }
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isPinching) {
                    this.isPinching = false;
                    // Reset pinch state
                    this.pinchStartDistance = 0;
                    this.pinchStartScale = 1;
                }
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isPanning) {
                    this.isPanning = false;
                    
                    // Calculate velocity for momentum scrolling
                    if (this.touchStart) {
                        const now = Date.now();
                        const timeDiff = now - this.touchStart.time;
                        
                        if (timeDiff > 0) {
                            const touch = e.changedTouches[0] || this.touchStart;
                            const deltaX = touch.clientX - this.touchStart.x;
                            const deltaY = touch.clientY - this.touchStart.y;
                            
                            this.velocity.x = deltaX / timeDiff * 16;
                            this.velocity.y = deltaY / timeDiff * 16;
                        }
                    }
                }
                
                if (this.isAnnotationMode && this.currentHighlight) {
                    this.finalizeHighlight();
                }
                
                this.touchStart = null;
            }

            handleMouseDown(e) {
                this.touchStart = {
                    x: e.clientX,
                    y: e.clientY,
                    time: Date.now(),
                    clientX: e.clientX,
                    clientY: e.clientY
                };

                const isLeftEdge = e.clientX < 50;
                const isRightEdge = e.clientX > window.innerWidth - 50;

                if (isLeftEdge || isRightEdge) {
                    this.isEdgeSwiping = true;
                }

                if (!this.isEdgeSwiping) {
                    this.longPressTimer = setTimeout(() => {
                        if (!this.isEdgeSwiping) {
                            this.enterAnnotationMode();
                        }
                    }, 650);
                }
            }

            handleMouseMove(e) {
                if (this.touchStart) {
                    const deltaX = e.clientX - this.touchStart.x;
                    const deltaY = e.clientY - this.touchStart.y;

                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;

                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                this.previousPage();
                            } else {
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            return;
                        }

                        // Handle mouse panning (with Ctrl key for testing)
                        if ((e.ctrlKey || this.transform.scale > this.baseScale) && !this.isAnnotationMode) {
                            this.transform.x += deltaX;
                            this.transform.y += deltaY;
                            
                            this.constrainPan();
                            
                            this.touchStart.x = e.clientX;
                            this.touchStart.y = e.clientY;
                            
                            this.applyTransform();
                        }

                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleHighlight(e.clientX, e.clientY);
                        }
                    }
                }
            }

            handleMouseUp() {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isAnnotationMode && this.currentHighlight) {
                    this.finalizeHighlight();
                }
                
                this.touchStart = null;
            }

            handleWheel(e) {
                // For desktop testing: Ctrl+Wheel to zoom
                if (e.ctrlKey) {
                    e.preventDefault();
                    
                    const rect = this.mainContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const oldScale = this.transform.scale;
                    const newScale = Math.max(this.minScale, Math.min(oldScale * zoomFactor, this.maxScale));
                    
                    if (newScale !== oldScale) {
                        // Calculate the point under the cursor in PDF coordinates
                        const pdfX = (x - this.transform.x) / oldScale;
                        const pdfY = (y - this.transform.y) / oldScale;
                        
                        // Apply new scale
                        this.transform.scale = newScale;
                        
                        // Adjust position to keep the point under cursor
                        this.transform.x = x - pdfX * newScale;
                        this.transform.y = y - pdfY * newScale;
                        
                        this.constrainPan();
                        this.applyTransform();
                        this.updateZoomIndicator();
                    }
                }
            }

            handleTap(e) {
                const now = Date.now();
                const timeSinceLastTap = now - this.lastTap;
                
                if (timeSinceLastTap < 300) {
                    // Double tap - reset zoom and position
                    this.resetZoom();
                    e.preventDefault();
                }
                
                this.lastTap = now;
            }

            handleClick(e) {
                // Check if clicking on a highlight
                if (this.isAnnotationMode) {
                    const rect = this.canvas.getBoundingClientRect();
                    const scale = this.transform.scale;
                    const x = (e.clientX - this.transform.x - rect.left) / scale;
                    const y = (e.clientY - this.transform.y - rect.top) / scale;
                    
                    const highlight = this.findHighlightAt(x, y);
                    if (highlight) {
                        this.showNoteSheet(highlight);
                    }
                }
            }

            getTouchCenter(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }

            getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            applyTransform() {
                this.pdfContainer.style.transform = `
                    translate(${this.transform.x}px, ${this.transform.y}px)
                    scale(${this.transform.scale})
                `;
            }

            constrainPan() {
                const canvasRect = this.canvas.getBoundingClientRect();
                const containerRect = this.mainContainer.getBoundingClientRect();
                
                const scaledWidth = canvasRect.width * this.transform.scale;
                const scaledHeight = canvasRect.height * this.transform.scale;
                
                // Calculate maximum allowed pan
                const maxX = Math.max(0, (scaledWidth - containerRect.width) / 2);
                const maxY = Math.max(0, (scaledHeight - containerRect.height) / 2);
                
                // Constrain pan to keep PDF within view
                this.transform.x = Math.max(-maxX, Math.min(maxX, this.transform.x));
                this.transform.y = Math.max(-maxY, Math.min(maxY, this.transform.y));
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                const now = Date.now();
                const deltaTime = Math.min(now - this.lastFrameTime, 100) / 16;
                this.lastFrameTime = now;
                
                // Apply momentum if panning ended with velocity
                if (!this.isPanning && !this.isPinching && (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1)) {
                    this.transform.x += this.velocity.x * deltaTime;
                    this.transform.y += this.velocity.y * deltaTime;
                    
                    // Apply constraints
                    this.constrainPan();
                    
                    // Apply damping
                    this.velocity.x *= 0.9;
                    this.velocity.y *= 0.9;
                    
                    // Apply transform
                    this.applyTransform();
                    
                    // Stop if velocity is very small
                    if (Math.abs(this.velocity.x) < 0.1 && Math.abs(this.velocity.y) < 0.1) {
                        this.velocity.x = 0;
                        this.velocity.y = 0;
                    }
                }
            }

            enterAnnotationMode() {
                this.isAnnotationMode = true;
                this.canvas.style.cursor = 'crosshair';
                document.getElementById('mode-indicator').style.display = 'block';
            }

            exitAnnotationMode() {
                this.isAnnotationMode = false;
                this.canvas.style.cursor = 'grab';
                document.getElementById('mode-indicator').style.display = 'none';
                this.currentHighlight = null;
                this.highlightStart = null;
            }

            handleHighlight(x, y) {
                const rect = this.canvas.getBoundingClientRect();
                const scale = this.transform.scale;
                const canvasX = (x - this.transform.x - rect.left) / scale;
                const canvasY = (y - this.transform.y - rect.top) / scale;
                
                if (!this.highlightStart) {
                    this.highlightStart = { x: canvasX, y: canvasY };
                    this.currentHighlight = {
                        x: canvasX,
                        y: canvasY,
                        width: 0,
                        height: 0,
                        page: this.currentPage
                    };
                } else {
                    this.currentHighlight.width = canvasX - this.highlightStart.x;
                    this.currentHighlight.height = canvasY - this.highlightStart.y;
                    
                    // Draw temporary highlight
                    this.drawHighlight(this.currentHighlight);
                }
            }

            finalizeHighlight() {
                if (this.currentHighlight && 
                    Math.abs(this.currentHighlight.width) > 10 && 
                    Math.abs(this.currentHighlight.height) > 10) {
                    
                    // Normalize coordinates
                    if (this.currentHighlight.width < 0) {
                        this.currentHighlight.x += this.currentHighlight.width;
                        this.currentHighlight.width = Math.abs(this.currentHighlight.width);
                    }
                    if (this.currentHighlight.height < 0) {
                        this.currentHighlight.y += this.currentHighlight.height;
                        this.currentHighlight.height = Math.abs(this.currentHighlight.height);
                    }
                    
                    // Add unique ID
                    this.currentHighlight.id = Date.now().toString();
                    
                    // Save highlight
                    this.saveHighlight(this.currentHighlight);
                    
                    // Draw permanent highlight
                    this.drawHighlight(this.currentHighlight, true);
                }
                
                this.currentHighlight = null;
                this.highlightStart = null;
            }

            drawHighlight(highlight, permanent = false) {
                if (!permanent) {
                    // Clear temporary highlights
                    const tempHighlights = document.querySelectorAll('.highlight:not([data-permanent])');
                    tempHighlights.forEach(el => el.remove());
                }
                
                const highlightEl = document.createElement('div');
                highlightEl.className = 'highlight';
                highlightEl.style.left = `${highlight.x * this.transform.scale}px`;
                highlightEl.style.top = `${highlight.y * this.transform.scale}px`;
                highlightEl.style.width = `${highlight.width * this.transform.scale}px`;
                highlightEl.style.height = `${highlight.height * this.transform.scale}px`;
                
                if (permanent) {
                    highlightEl.setAttribute('data-id', highlight.id);
                    highlightEl.setAttribute('data-permanent', 'true');
                    highlightEl.style.position = 'absolute';
                    
                    highlightEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (this.isAnnotationMode) {
                            this.showNoteSheet(highlight);
                        }
                    });
                    
                    highlightEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (this.isAnnotationMode) {
                            this.deleteHighlight(highlight.id);
                        }
                    });
                }
                
                this.pdfContainer.appendChild(highlightEl);
            }

            findHighlightAt(x, y) {
                const highlights = this.annotations.get(this.currentPage) || [];
                return highlights.find(h => 
                    x >= h.x && x <= h.x + h.width &&
                    y >= h.y && y <= h.y + h.height
                );
            }

            async renderPage(pageNum) {
                if (!this.pdfDoc || pageNum < 1 || pageNum > this.pdfDoc.numPages) return;
                
                this.currentPage = pageNum;
                document.getElementById('page-num').textContent = pageNum;
                
                // Remove all highlights
                document.querySelectorAll('.highlight').forEach(el => el.remove());
                
                const page = await this.pdfDoc.getPage(pageNum);
                
                // Calculate initial viewport
                const viewport = page.getViewport({ scale: 1 });
                
                // Calculate scale to fit screen
                const containerWidth = window.innerWidth * 0.95;
                const containerHeight = window.innerHeight * 0.85;
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                const fitScale = Math.min(scaleX, scaleY);
                
                // Set base scale and current scale
                this.baseScale = fitScale;
                this.currentScale = fitScale;
                this.transform.scale = fitScale;
                this.minScale = fitScale * 0.5;
                this.maxScale = fitScale * 3.0;
                
                // Reset position
                this.transform.x = 0;
                this.transform.y = 0;
                this.velocity = { x: 0, y: 0 };
                
                // Calculate actual viewport with scale
                const actualViewport = page.getViewport({ scale: fitScale });
                
                // Set canvas dimensions
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = Math.floor(actualViewport.width * dpr);
                this.canvas.height = Math.floor(actualViewport.height * dpr);
                
                // Scale canvas for display
                this.canvas.style.width = `${actualViewport.width}px`;
                this.canvas.style.height = `${actualViewport.height}px`;
                
                // Update render context
                this.renderContext.viewport = actualViewport;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render PDF page
                await page.render(this.renderContext).promise;
                
                // Apply initial transform
                this.applyTransform();
                
                // Update zoom indicator
                this.updateZoomIndicator();
                
                // Restore annotations for this page
                this.restoreAnnotations();
                
                // Exit annotation mode after page change
                this.exitAnnotationMode();
            }

            updateZoomIndicator() {
                const percentage = Math.round((this.transform.scale / this.baseScale) * 100);
                document.getElementById('zoom-indicator').textContent = `${percentage}%`;
            }

            handleResize() {
                // Recalculate base scale on resize
                this.baseScale = 1.0;
                this.renderPage(this.currentPage);
            }

            nextPage() {
                if (this.currentPage < this.pdfDoc.numPages && !this.isAnnotationMode) {
                    this.renderPage(this.currentPage + 1);
                }
            }

            previousPage() {
                if (this.currentPage > 1 && !this.isAnnotationMode) {
                    this.renderPage(this.currentPage - 1);
                }
            }

            resetZoom() {
                // Animate to center and base scale
                this.transform.scale = this.baseScale;
                this.transform.x = 0;
                this.transform.y = 0;
                this.velocity = { x: 0, y: 0 };
                
                this.applyTransform();
                this.updateZoomIndicator();
            }

            saveHighlight(highlight) {
                const pageHighlights = this.annotations.get(highlight.page) || [];
                pageHighlights.push(highlight);
                this.annotations.set(highlight.page, pageHighlights);
                
                this.saveToStorage();
            }

            restoreAnnotations() {
                // Draw highlights for current page
                const pageHighlights = this.annotations.get(this.currentPage) || [];
                pageHighlights.forEach(highlight => {
                    this.drawHighlight(highlight, true);
                });
            }

            showNoteSheet(highlight) {
                this.activeHighlight = highlight;
                
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                const noteText = document.getElementById('note-text');
                
                // Load existing note
                noteText.value = highlight.note || '';
                
                noteSheet.classList.add('active');
                overlay.classList.add('active');
            }

            hideNoteSheet() {
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                
                noteSheet.classList.remove('active');
                overlay.classList.remove('active');
                
                this.activeHighlight = null;
            }

            saveNote() {
                if (!this.activeHighlight) return;
                
                const noteText = document.getElementById('note-text').value;
                this.activeHighlight.note = noteText;
                
                // Update in annotations
                const pageHighlights = this.annotations.get(this.activeHighlight.page) || [];
                const index = pageHighlights.findIndex(h => h.id === this.activeHighlight.id);
                if (index !== -1) {
                    pageHighlights[index].note = noteText;
                    this.saveToStorage();
                }
                
                this.hideNoteSheet();
            }

            deleteHighlight(highlightId = null) {
                const id = highlightId || (this.activeHighlight && this.activeHighlight.id);
                if (!id) return;
                
                // Remove from DOM
                const highlightEl = document.querySelector(`.highlight[data-id="${id}"]`);
                if (highlightEl) {
                    highlightEl.remove();
                }
                
                // Remove from annotations
                const pageHighlights = this.annotations.get(this.currentPage) || [];
                const filtered = pageHighlights.filter(h => h.id !== id);
                this.annotations.set(this.currentPage, filtered);
                
                this.saveToStorage();
                this.hideNoteSheet();
            }

            saveToStorage() {
                const data = Object.fromEntries(this.annotations);
                localStorage.setItem('pdfAnnotations', JSON.stringify(data));
            }

            loadAnnotations() {
                const saved = localStorage.getItem('pdfAnnotations');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.annotations = new Map(Object.entries(data));
                }
            }
        }

        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.viewer = new GesturePDFViewer();
        });
    </script>
</body>
</html>