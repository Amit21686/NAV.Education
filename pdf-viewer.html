<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #121212;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
            touch-action: none; /* Disable browser gestures */
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: #1a1a1a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pdf-viewport {
            position: relative;
            overflow: visible;
            max-width: 100%;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-wrapper {
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s;
        }

        #pdf-canvas {
            display: block;
            background: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            max-height: 90vh;
            cursor: grab;
        }

        #pdf-canvas:active {
            cursor: grabbing;
        }

        .annotation-mode {
            cursor: crosshair !important;
        }

        .page-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            z-index: 100;
            pointer-events: none;
        }

        .mode-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            z-index: 100;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
            display: none;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .highlight {
            position: absolute;
            background: rgba(255, 235, 59, 0.4);
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
            z-index: 10;
            pointer-events: auto;
        }

        .highlight:hover {
            background: rgba(255, 235, 59, 0.6);
        }

        .note-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2d2d2d;
            border-radius: 24px 24px 0 0;
            padding: 24px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }

        .note-sheet.active {
            transform: translateY(0);
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .note-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
        }

        .close-btn {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            background: #3b3b3b;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .note-textarea {
            width: 100%;
            height: 150px;
            background: #3b3b3b;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
            color: white;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            margin-bottom: 20px;
        }

        .note-textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .save-btn {
            width: 100%;
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .save-btn:hover {
            background: #2563eb;
        }

        .delete-btn {
            width: 100%;
            padding: 16px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 12px;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }

        .swipe-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 12px;
            color: #aaa;
            backdrop-filter: blur(10px);
            pointer-events: none;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        .zoom-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .touch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="pdf-viewport" id="pdf-viewport">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <canvas id="pdf-canvas"></canvas>
            </div>
        </div>
        
        <div class="page-info">Page: <span id="page-num">1</span> / <span id="page-count">1</span></div>
        <div class="mode-indicator" id="mode-indicator">Annotation Mode</div>
        <div class="zoom-indicator" id="zoom-indicator">100%</div>
        
        <div class="touch-overlay" id="touch-overlay"></div>
        <div class="loading" id="loading">Loading PDF...</div>
        <div class="swipe-hint">Swipe from edges to change pages • Pinch to zoom • Double tap to reset</div>
    </div>

    <div class="overlay" id="overlay"></div>
    
    <div class="note-sheet" id="note-sheet">
        <div class="note-header">
            <div class="note-title">Note</div>
            <button class="close-btn" id="close-note">×</button>
        </div>
        <textarea class="note-textarea" id="note-text" placeholder="Type your note here..."></textarea>
        <button class="save-btn" id="save-note">Save Note</button>
        <button class="delete-btn" id="delete-highlight">Delete Highlight</button>
    </div>

    <script>
        class GesturePDFViewer {
            constructor() {
                this.pdfDoc = null;
                this.currentPage = 1;
                this.currentScale = 1.0;
                this.baseScale = 1.0;
                this.renderContext = null;
                this.canvas = document.getElementById('pdf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasWrapper = document.getElementById('canvas-wrapper');
                this.pdfViewport = document.getElementById('pdf-viewport');
                
                this.isAnnotationMode = false;
                this.isPinching = false;
                this.isEdgeSwiping = false;
                this.isDragging = false;
                
                this.annotations = new Map();
                this.currentHighlight = null;
                this.activeHighlight = null;
                this.highlightStart = null;
                
                this.touchStart = null;
                this.lastTap = 0;
                this.longPressTimer = null;
                this.pinchStartDistance = 0;
                this.pinchStartScale = 1.0;
                this.initialTouches = [];
                
                this.init();
            }

            async init() {
                // For demo, using a sample PDF URL
                // Replace with your PDF loading logic
                const pdfUrl = 'https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf';
                
                try {
                    document.getElementById('loading').style.display = 'block';
                    
                    // Load PDF
                    const loadingTask = pdfjsLib.getDocument(pdfUrl);
                    this.pdfDoc = await loadingTask.promise;
                    
                    document.getElementById('page-count').textContent = this.pdfDoc.numPages;
                    
                    // Setup canvas
                    this.setupCanvas();
                    
                    // Load annotations
                    this.loadAnnotations();
                    
                    // Render first page
                    await this.renderPage(this.currentPage);
                    
                    document.getElementById('loading').style.display = 'none';
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    document.getElementById('loading').textContent = 'Error loading PDF';
                }
            }

            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.renderContext = {
                    canvasContext: this.ctx,
                    viewport: null,
                    transform: [dpr, 0, 0, dpr, 0, 0]
                };
            }

            setupEventListeners() {
                const touchOverlay = document.getElementById('touch-overlay');
                
                // Touch events on the overlay
                touchOverlay.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                touchOverlay.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                touchOverlay.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Mouse events (for desktop testing)
                touchOverlay.addEventListener('mousedown', this.handleMouseDown.bind(this));
                touchOverlay.addEventListener('mousemove', this.handleMouseMove.bind(this));
                touchOverlay.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Double tap detection
                touchOverlay.addEventListener('touchend', this.handleTap.bind(this));
                touchOverlay.addEventListener('click', this.handleClick.bind(this));
                
                // Note sheet controls
                document.getElementById('close-note').addEventListener('click', () => this.hideNoteSheet());
                document.getElementById('save-note').addEventListener('click', () => this.saveNote());
                document.getElementById('delete-highlight').addEventListener('click', () => this.deleteHighlight());
                document.getElementById('overlay').addEventListener('click', () => this.hideNoteSheet());
                
                // Handle viewport resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            handleTouchStart(e) {
                if (e.touches.length === 2) {
                    // PINCH ZOOM START
                    this.isPinching = true;
                    this.isAnnotationMode = false;
                    document.getElementById('mode-indicator').style.display = 'none';
                    
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Store initial touches for center calculation
                    this.initialTouches = [
                        { x: touch1.clientX, y: touch1.clientY },
                        { x: touch2.clientX, y: touch2.clientY }
                    ];
                    
                    this.pinchStartDistance = this.getTouchDistance(touch1, touch2);
                    this.pinchStartScale = this.currentScale;
                    
                    e.preventDefault();
                    return;
                }

                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    this.touchStart = {
                        x: touch.clientX,
                        y: touch.clientY,
                        time: Date.now(),
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    
                    // Check if touch started in edge zone (50px from edges)
                    const screenWidth = window.innerWidth;
                    const isLeftEdge = touch.clientX < 50;
                    const isRightEdge = touch.clientX > screenWidth - 50;
                    
                    if (isLeftEdge || isRightEdge) {
                        this.isEdgeSwiping = true;
                        console.log(`${isLeftEdge ? 'Left' : 'Right'} edge touch detected`);
                    }

                    // Start long press timer for annotation mode
                    if (!this.isPinching && !this.isEdgeSwiping) {
                        this.longPressTimer = setTimeout(() => {
                            if (!this.isPinching && !this.isEdgeSwiping) {
                                this.enterAnnotationMode();
                            }
                        }, 650);
                    }
                    
                    e.preventDefault();
                }
            }

            handleTouchMove(e) {
                if (e.touches.length === 2 && this.isPinching) {
                    // HANDLE PINCH ZOOM
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = this.getTouchDistance(touch1, touch2);
                    
                    if (this.pinchStartDistance > 0) {
                        const scaleChange = currentDistance / this.pinchStartDistance;
                        const newScale = this.pinchStartScale * scaleChange;
                        
                        // Limit zoom scale (0.5x to 3x)
                        this.currentScale = Math.max(0.5, Math.min(newScale, 3.0));
                        
                        // Calculate center point between two fingers
                        const centerX = (touch1.clientX + touch2.clientX) / 2;
                        const centerY = (touch1.clientY + touch2.clientY) / 2;
                        
                        // Apply zoom transform centered on pinch point
                        this.applyZoom(this.currentScale, centerX, centerY);
                        
                        // Update zoom indicator
                        document.getElementById('zoom-indicator').textContent = 
                            `${Math.round(this.currentScale * 100)}%`;
                    }
                    
                    e.preventDefault();
                    return;
                }

                if (e.touches.length === 1 && this.touchStart) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touchStart.x;
                    const deltaY = touch.clientY - this.touchStart.y;
                    
                    // Clear long press timer if movement detected
                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                        
                        // Handle edge swipe for page change
                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                // Swipe right from left edge - previous page
                                console.log('Previous page swipe detected');
                                this.previousPage();
                            } else {
                                // Swipe left from right edge - next page
                                console.log('Next page swipe detected');
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            e.preventDefault();
                            return;
                        }
                        
                        // Handle highlighting in annotation mode
                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleHighlight(touch.clientX, touch.clientY);
                        }
                    }
                    
                    e.preventDefault();
                }
            }

            handleTouchEnd(e) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isPinching) {
                    this.isPinching = false;
                    // Re-render PDF at new scale for better quality
                    setTimeout(() => {
                        this.renderPage(this.currentPage);
                    }, 50);
                }
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isAnnotationMode && this.currentHighlight) {
                    this.finalizeHighlight();
                }
                
                this.touchStart = null;
                this.initialTouches = [];
            }

            handleMouseDown(e) {
                this.touchStart = {
                    x: e.clientX,
                    y: e.clientY,
                    time: Date.now(),
                    clientX: e.clientX,
                    clientY: e.clientY
                };

                const isLeftEdge = e.clientX < 50;
                const isRightEdge = e.clientX > window.innerWidth - 50;

                if (isLeftEdge || isRightEdge) {
                    this.isEdgeSwiping = true;
                }

                if (!this.isEdgeSwiping) {
                    this.longPressTimer = setTimeout(() => {
                        if (!this.isEdgeSwiping) {
                            this.enterAnnotationMode();
                        }
                    }, 650);
                }
            }

            handleMouseMove(e) {
                if (this.touchStart) {
                    const deltaX = e.clientX - this.touchStart.x;
                    const deltaY = e.clientY - this.touchStart.y;

                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;

                        if (this.isEdgeSwiping && Math.abs(deltaX) > 60 && Math.abs(deltaY) < 80) {
                            if (deltaX > 0) {
                                this.previousPage();
                            } else {
                                this.nextPage();
                            }
                            
                            this.isEdgeSwiping = false;
                            this.touchStart = null;
                            return;
                        }

                        if (this.isAnnotationMode && !this.isEdgeSwiping) {
                            this.handleHighlight(e.clientX, e.clientY);
                        }
                    }
                }
            }

            handleMouseUp() {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
                
                if (this.isEdgeSwiping) {
                    this.isEdgeSwiping = false;
                }
                
                if (this.isAnnotationMode && this.currentHighlight) {
                    this.finalizeHighlight();
                }
                
                this.touchStart = null;
            }

            handleTap(e) {
                const now = Date.now();
                const timeSinceLastTap = now - this.lastTap;
                
                if (timeSinceLastTap < 300) {
                    // Double tap - reset zoom
                    this.resetZoom();
                    e.preventDefault();
                }
                
                this.lastTap = now;
            }

            handleClick(e) {
                // Check if clicking on a highlight
                if (this.isAnnotationMode) {
                    const rect = this.canvas.getBoundingClientRect();
                    const scale = this.currentScale;
                    const x = (e.clientX - rect.left) / scale;
                    const y = (e.clientY - rect.top) / scale;
                    
                    const highlight = this.findHighlightAt(x, y);
                    if (highlight) {
                        this.showNoteSheet(highlight);
                    }
                }
            }

            getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            applyZoom(scale, centerX, centerY) {
                // Apply CSS transform for smooth zooming
                this.canvasWrapper.style.transform = `scale(${scale})`;
                
                // Center the zoom on the pinch point
                const rect = this.pdfViewport.getBoundingClientRect();
                const offsetX = centerX - rect.left;
                const offsetY = centerY - rect.top;
                
                // Adjust transform origin for centered zoom
                this.canvasWrapper.style.transformOrigin = `${offsetX}px ${offsetY}px`;
            }

            enterAnnotationMode() {
                this.isAnnotationMode = true;
                this.canvas.style.cursor = 'crosshair';
                document.getElementById('mode-indicator').style.display = 'block';
                console.log('Annotation mode activated');
            }

            exitAnnotationMode() {
                this.isAnnotationMode = false;
                this.canvas.style.cursor = 'grab';
                document.getElementById('mode-indicator').style.display = 'none';
                this.currentHighlight = null;
                this.highlightStart = null;
            }

            handleHighlight(x, y) {
                const rect = this.canvas.getBoundingClientRect();
                const scale = this.currentScale;
                const canvasX = (x - rect.left) / scale;
                const canvasY = (y - rect.top) / scale;
                
                if (!this.highlightStart) {
                    this.highlightStart = { x: canvasX, y: canvasY };
                    this.currentHighlight = {
                        x: canvasX,
                        y: canvasY,
                        width: 0,
                        height: 0,
                        page: this.currentPage
                    };
                } else {
                    this.currentHighlight.width = canvasX - this.highlightStart.x;
                    this.currentHighlight.height = canvasY - this.highlightStart.y;
                    
                    // Draw temporary highlight
                    this.drawHighlight(this.currentHighlight);
                }
            }

            finalizeHighlight() {
                if (this.currentHighlight && 
                    Math.abs(this.currentHighlight.width) > 10 && 
                    Math.abs(this.currentHighlight.height) > 10) {
                    
                    // Normalize coordinates
                    if (this.currentHighlight.width < 0) {
                        this.currentHighlight.x += this.currentHighlight.width;
                        this.currentHighlight.width = Math.abs(this.currentHighlight.width);
                    }
                    if (this.currentHighlight.height < 0) {
                        this.currentHighlight.y += this.currentHighlight.height;
                        this.currentHighlight.height = Math.abs(this.currentHighlight.height);
                    }
                    
                    // Add unique ID
                    this.currentHighlight.id = Date.now().toString();
                    
                    // Save highlight
                    this.saveHighlight(this.currentHighlight);
                    
                    // Draw permanent highlight
                    this.drawHighlight(this.currentHighlight, true);
                }
                
                this.currentHighlight = null;
                this.highlightStart = null;
            }

            drawHighlight(highlight, permanent = false) {
                if (!permanent) {
                    // Clear temporary highlights
                    const tempHighlights = document.querySelectorAll('.highlight:not([data-permanent])');
                    tempHighlights.forEach(el => el.remove());
                }
                
                const highlightEl = document.createElement('div');
                highlightEl.className = 'highlight';
                highlightEl.style.left = `${highlight.x * this.currentScale}px`;
                highlightEl.style.top = `${highlight.y * this.currentScale}px`;
                highlightEl.style.width = `${highlight.width * this.currentScale}px`;
                highlightEl.style.height = `${highlight.height * this.currentScale}px`;
                
                if (permanent) {
                    highlightEl.setAttribute('data-id', highlight.id);
                    highlightEl.setAttribute('data-permanent', 'true');
                    
                    highlightEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (this.isAnnotationMode) {
                            this.showNoteSheet(highlight);
                        }
                    });
                    
                    highlightEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (this.isAnnotationMode) {
                            this.deleteHighlight(highlight.id);
                        }
                    });
                }
                
                this.canvasWrapper.appendChild(highlightEl);
            }

            findHighlightAt(x, y) {
                const highlights = this.annotations.get(this.currentPage) || [];
                return highlights.find(h => 
                    x >= h.x && x <= h.x + h.width &&
                    y >= h.y && y <= h.y + h.height
                );
            }

            async renderPage(pageNum) {
                if (!this.pdfDoc || pageNum < 1 || pageNum > this.pdfDoc.numPages) return;
                
                this.currentPage = pageNum;
                document.getElementById('page-num').textContent = pageNum;
                
                const page = await this.pdfDoc.getPage(pageNum);
                
                // Calculate viewport with current scale
                const viewport = page.getViewport({ scale: this.currentScale });
                
                // Calculate the maximum scale that fits the screen
                const containerWidth = window.innerWidth * 0.95; // 95% of screen width
                const containerHeight = window.innerHeight * 0.85; // 85% of screen height
                
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                const fitScale = Math.min(scaleX, scaleY);
                
                // Use fit scale as base if this is first render or reset
                if (this.baseScale === 1.0 || this.currentScale === 1.0) {
                    this.currentScale = fitScale;
                    this.baseScale = fitScale;
                }
                
                // Recalculate viewport with actual scale
                const actualViewport = page.getViewport({ scale: this.currentScale });
                
                // Set canvas dimensions
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = Math.floor(actualViewport.width * dpr);
                this.canvas.height = Math.floor(actualViewport.height * dpr);
                
                // Scale canvas for display
                this.canvas.style.width = `${actualViewport.width}px`;
                this.canvas.style.height = `${actualViewport.height}px`;
                
                // Update render context
                this.renderContext.viewport = actualViewport;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render PDF page
                await page.render(this.renderContext).promise;
                
                // Reset transform
                this.canvasWrapper.style.transform = 'scale(1)';
                this.canvasWrapper.style.transformOrigin = 'center center';
                
                // Update zoom indicator
                document.getElementById('zoom-indicator').textContent = 
                    `${Math.round(this.currentScale / this.baseScale * 100)}%`;
                
                // Restore annotations for this page
                this.restoreAnnotations();
                
                // Exit annotation mode after page change
                this.exitAnnotationMode();
                
                console.log(`Rendered page ${pageNum} at ${Math.round(this.currentScale / this.baseScale * 100)}%`);
            }

            handleResize() {
                // Recalculate base scale on resize
                this.baseScale = 1.0;
                this.renderPage(this.currentPage);
            }

            nextPage() {
                if (this.currentPage < this.pdfDoc.numPages && !this.isAnnotationMode) {
                    console.log('Changing to next page');
                    this.renderPage(this.currentPage + 1);
                }
            }

            previousPage() {
                if (this.currentPage > 1 && !this.isAnnotationMode) {
                    console.log('Changing to previous page');
                    this.renderPage(this.currentPage - 1);
                }
            }

            resetZoom() {
                console.log('Resetting zoom');
                this.currentScale = this.baseScale;
                this.renderPage(this.currentPage);
            }

            saveHighlight(highlight) {
                const pageHighlights = this.annotations.get(highlight.page) || [];
                pageHighlights.push(highlight);
                this.annotations.set(highlight.page, pageHighlights);
                
                this.saveToStorage();
            }

            restoreAnnotations() {
                // Remove all existing highlights
                document.querySelectorAll('.highlight[data-permanent]').forEach(el => el.remove());
                
                // Draw highlights for current page
                const pageHighlights = this.annotations.get(this.currentPage) || [];
                pageHighlights.forEach(highlight => {
                    this.drawHighlight(highlight, true);
                });
            }

            showNoteSheet(highlight) {
                this.activeHighlight = highlight;
                
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                const noteText = document.getElementById('note-text');
                
                // Load existing note
                noteText.value = highlight.note || '';
                
                noteSheet.classList.add('active');
                overlay.classList.add('active');
            }

            hideNoteSheet() {
                const noteSheet = document.getElementById('note-sheet');
                const overlay = document.getElementById('overlay');
                
                noteSheet.classList.remove('active');
                overlay.classList.remove('active');
                
                this.activeHighlight = null;
            }

            saveNote() {
                if (!this.activeHighlight) return;
                
                const noteText = document.getElementById('note-text').value;
                this.activeHighlight.note = noteText;
                
                // Update in annotations
                const pageHighlights = this.annotations.get(this.activeHighlight.page) || [];
                const index = pageHighlights.findIndex(h => h.id === this.activeHighlight.id);
                if (index !== -1) {
                    pageHighlights[index].note = noteText;
                    this.saveToStorage();
                }
                
                this.hideNoteSheet();
            }

            deleteHighlight(highlightId = null) {
                const id = highlightId || (this.activeHighlight && this.activeHighlight.id);
                if (!id) return;
                
                // Remove from DOM
                const highlightEl = document.querySelector(`.highlight[data-id="${id}"]`);
                if (highlightEl) {
                    highlightEl.remove();
                }
                
                // Remove from annotations
                const pageHighlights = this.annotations.get(this.currentPage) || [];
                const filtered = pageHighlights.filter(h => h.id !== id);
                this.annotations.set(this.currentPage, filtered);
                
                this.saveToStorage();
                this.hideNoteSheet();
            }

            saveToStorage() {
                const data = Object.fromEntries(this.annotations);
                localStorage.setItem('pdfAnnotations', JSON.stringify(data));
            }

            loadAnnotations() {
                const saved = localStorage.getItem('pdfAnnotations');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.annotations = new Map(Object.entries(data));
                }
            }
        }

        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.viewer = new GesturePDFViewer();
        });
    </script>
</body>
</html>